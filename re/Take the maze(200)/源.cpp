//####################################################################################################
//                                   reverse200:Take the maze
//                                        author:0x61
//                                           zsctf
//                                         2017.8.18
//####################################################################################################
#include <cstdio>
#include <string.h>
#include <stdlib.h>
#include <stdint.h>
#include <time.h>
#include<Windows.h>
#include<iostream>
using namespace std;
//------------------------------------------map---------------------------------------------------------
int p1[] = 
{ 42,468,335,1,170,225,479,359,463,465,206,146,282,328,462,492,496,443,328,437,392,105,403,154,293,383,
422,217,219,396,448,227,272,39,370,413,168,300,36,395,204,312,323,334,174,165,142,212,254,369,48,145,
163,258,38,360,224,242,30,279,317,36,191,343,289,107,41,443,265,149,447,306,391,230,371,351,7,102,
394,49,130,124,85,455,257,341,467,377,432,309,445,440,127,324,38,39,119,83,430,42,334,116,140,159,
205,431,478,307,174,387,22,246,425,73,271,330,278,74,98,13,487,291,162,137,356,268,156,75,32,53,
351,151,442,225,467,431,108,192,8,338,458,288,254,384,446,410,210,259,222,89,423,447,7,31,414,169,
401,92,263,156,411,360,125,38,49,484,96,42,103,351,292,337,375,21,97,22,349,200,169,485,282,235,
54,500,419,439,401,289,128,468,229,394,149,484,308,422,311,118,314,15,310,117,436,452,101,250,20,57,
299,304,225,9,345,110,490,203,196,486,94,344,24,88,315,4,449,201,459,119,81,297,299,282,90,299,
10,158,473,123,39,293,39,180,191,158,459,192,316,389,157,12,203,135,273,56,329,147,363,387,376,434,
370,143,345,417,382,499,323,152,22,200,58,477,393,390,76,213,101,11,4,370,362,189,402,290,256,424,
3,86,183,286,89,427,118,258,333,433,170,155,222,190,477,330,369,193,426,56,435,50,442,13,146,61 };
int p2[] = 
{ 42,469,334,1,170,225,479,359,462,464,207,147,283,329,463,493,497,442,329,436,393,104,402,155,292,382,
422,217,218,396,449,226,273,39,371,412,168,300,36,395,204,312,323,334,174,165,142,213,255,368,49,144,
162,258,38,360,225,243,31,279,316,37,191,342,288,106,40,442,264,148,446,307,391,231,370,350,6,103,
394,49,131,125,84,454,256,341,467,377,432,309,444,441,126,325,39,39,119,82,430,43,335,117,141,158,
204,431,478,306,175,386,23,247,424,72,270,330,279,75,99,12,486,290,162,136,357,269,157,74,33,52,
350,150,442,225,467,431,108,192,8,339,459,288,254,384,446,410,210,259,222,89,423,446,6,30,415,168,
400,93,262,157,411,361,124,39,49,485,97,43,102,350,293,336,374,20,96,23,349,201,168,484,283,234,
55,501,418,438,401,288,129,469,229,395,148,485,309,423,310,119,315,14,311,116,436,453,100,251,21,56,
298,305,224,8,345,111,491,202,196,486,94,344,24,89,314,5,448,200,458,119,81,296,298,283,91,298,
11,159,472,122,39,292,38,181,190,159,458,193,316,388,156,13,202,134,272,57,328,146,362,386,377,435,
371,142,344,416,382,498,322,153,23,201,59,476,393,390,76,213,101,11,4,370,362,189,403,291,257,425,
2,87,182,287,88,426,119,259,332,432,171,154,223,191,476,331,368,192,427,57,434,50,442,13,146,61 };
//-------------------------------------------------------------------------------------------------------

//-----------------------------------------QR code-------------------------------------------------------
char p[] = { 0x89,0x50,0x4E,0x47,0x0D,0x0A,0x1A,0x0A,0x00,0x00,0x00,0x0D,0x49,0x48,0x44,0x52,0x00,0x00,0x01,0x18,
0x00,0x00,0x01,0x18,0x08,0x02,0x00,0x00,0x00,0x08,0xEC,0x7E,0xDB,0x00,0x00,0x07,0x6C,0x49,0x44,0x41,0x54,0x78,0x9C,
0xED,0xDD,0x4B,0x8E,0x23,0x3B,0x12,0x45,0xC1,0xCC,0xC6,0xDB,0xFF,0x96,0xAB,0x17,0xA0,0x18,0x10,0xE4,0x61,0x90,0x4A,
0x98,0x0D,0x0B,0x8A,0x9F,0x52,0x17,0x04,0xBC,0x3C,0x9C,0xBF,0xFF,0xFE,0xFD,0xFB,0x01,0xD6,0xFC,0xEF,0xF4,0x0D,0xC0,
0x5F,0x20,0x48,0x10,0x10,0x24,0x08,0x08,0x12,0x04,0x04,0x09,0x02,0xFF,0x7D,0xFE,0xD3,0xEF,0xEF,0xEF,0xFB,0xF7,0xF1,
0xE8,0xBB,0x2A,0x8A,0x83,0xDF,0xDB,0xE0,0x43,0x3D,0x9E,0x6D,0xE5,0xD8,0x69,0x97,0xFC,0x15,0x2E,0xFF,0x59,0x5A,0x91,
0x20,0x20,0x48,0x10,0x10,0x24,0x08,0x08,0x12,0x04,0x04,0x09,0x02,0x82,0x04,0x81,0x87,0xF2,0xF7,0xA3,0xDD,0x35,0xD0,
0xC1,0xE2,0xE6,0x3D,0x85,0xDD,0xB6,0xD8,0xDD,0xFA,0xBC,0xE8,0xCA,0xF7,0xF6,0x79,0x6C,0x5B,0x85,0x5F,0xF9,0x8A,0x2E,
0xF9,0x59,0xFE,0x58,0x91,0x20,0x21,0x48,0x10,0x10,0x24,0x08,0x08,0x12,0x04,0x04,0x09,0x02,0xA3,0x55,0xBB,0x4F,0x2B,
0x85,0xA0,0xE9,0x62,0xCB,0xE3,0x81,0x6D,0x29,0x6F,0xBA,0xD6,0xF4,0x78,0xE0,0x60,0xC9,0x6B,0xFA,0x63,0x83,0xF7,0xD6,
0x76,0xCA,0x0E,0x7E,0xEC,0x85,0xF6,0xDC,0xC1,0xB3,0x0D,0x5A,0xA9,0x01,0x5A,0x91,0x20,0x20,0x48,0x10,0x10,0x24,0x08,
0x08,0x12,0x04,0x04,0x09,0x02,0x82,0x04,0x81,0xF9,0xF2,0xF7,0xCD,0x06,0x6B,0xC7,0x2B,0x5D,0x95,0xBB,0x3B,0x32,0x5F,
0x98,0xD9,0x30,0x58,0xB0,0x9E,0xEE,0x27,0x1E,0xBC,0xDB,0x4B,0x66,0x42,0x2C,0xB2,0x22,0x41,0x40,0x90,0x20,0x20,0x48,
0x10,0x10,0x24,0x08,0x08,0x12,0x04,0xFE,0x42,0xD5,0xAE,0x7D,0xB3,0x3A,0xBC,0x8D,0xC7,0x3B,0x79,0xFC,0x58,0xDB,0x02,
0xBB,0xBB,0x0E,0xF6,0x42,0xEB,0xF0,0xD7,0xB1,0x22,0x41,0x40,0x90,0x20,0x20,0x48,0x10,0x10,0x24,0x08,0x08,0x12,0x04,
0x04,0x09,0x02,0xF3,0xE5,0xEF,0x23,0xBD,0x86,0x2F,0xB4,0x99,0x0E,0x9A,0x9E,0x64,0xF0,0xA8,0x9D,0xD9,0x30,0xAD,0x9D,
0xD9,0x30,0x7E,0x89,0xE9,0xB3,0x85,0x07,0x2E,0xB2,0x22,0x41,0x40,0x90,0x20,0x20,0x48,0x10,0x10,0x24,0x08,0x08,0x12,
0x04,0x46,0xAB,0x76,0x37,0xB7,0x24,0x4E,0x97,0x95,0x5E,0x28,0x52,0x7D,0x3A,0x72,0x6F,0xED,0x23,0x0C,0x5A,0xB9,0xB7,
0x95,0x4B,0x1C,0x61,0x45,0x82,0x80,0x20,0x41,0x40,0x90,0x20,0x20,0x48,0x10,0x10,0x24,0x08,0x08,0x12,0x04,0x1E,0xCA,
0xDF,0x7F,0x60,0xF2,0x65,0x3B,0x31,0xF4,0x88,0x23,0x43,0x4F,0x57,0xEC,0xBE,0xE8,0xE5,0x3F,0x4B,0x2B,0x12,0x04,0x04,
0x09,0x02,0x82,0x04,0x01,0x41,0x82,0x80,0x20,0x41,0x60,0xFB,0xA4,0xD5,0xDD,0x2F,0x78,0x8F,0x5F,0xB4,0x7D,0xEB,0x7B,
0xFA,0xFC,0x2B,0xD5,0xA7,0xB6,0x72,0x35,0xFD,0xA7,0xB9,0xE7,0x35,0xF8,0x4F,0x2B,0x5F,0xD1,0x4A,0xE1,0xD1,0x8A,0x04,
0x01,0x41,0x82,0x80,0x20,0x41,0x40,0x90,0x20,0x20,0x48,0x10,0x10,0x24,0x08,0xFC,0x4E,0xBF,0x43,0xBF,0x52,0x03,0xBD,
0xA4,0x01,0xF1,0xC8,0x6C,0xD4,0xB6,0x76,0x7C,0x49,0x41,0xFC,0xF1,0x4E,0x5E,0x98,0x75,0xD1,0x5A,0xF9,0x32,0xAD,0x48,
0x10,0x10,0x24,0x08,0x08,0x12,0x04,0x04,0x09,0x02,0x82,0x04,0x81,0xF9,0x57,0xCD,0xDB,0x2A,0xCA,0x91,0xDE,0xD6,0x95,
0x3A,0xDB,0x25,0xD3,0x4C,0x1F,0xED,0x2E,0x70,0xAD,0x7C,0x6F,0x23,0x07,0x8E,0x1F,0x3B,0x78,0xE0,0xF4,0x17,0x32,0x7E,
0x6F,0x56,0x24,0x08,0x08,0x12,0x04,0x04,0x09,0x02,0x82,0x04,0x01,0x41,0x82,0x80,0x20,0x41,0xE0,0xA1,0xFC,0xFD,0x42,
0xD3,0xEA,0xF4,0xD9,0x06,0x3F,0xD6,0x36,0x5F,0xB6,0xDA,0x4E,0xD9,0x47,0xED,0x66,0x5E,0xBB,0xB7,0x54,0x3B,0x22,0x1F,
0x3B,0x61,0x45,0x82,0x80,0x20,0x41,0x40,0x90,0x20,0x20,0x48,0x10,0x10,0x24,0x08,0x8C,0x36,0xAD,0xEE,0xAE,0x17,0xDD,
0xBC,0xCD,0xFD,0xA3,0xDD,0x03,0x59,0xEF,0x29,0xEE,0xB5,0x4F,0x7A,0xF3,0x16,0x4F,0x2B,0xAC,0x48,0x10,0x10,0x24,0x08,
0x08,0x12,0x04,0x04,0x09,0x02,0x82,0x04,0x01,0x41,0x82,0xC0,0x68,0xD3,0x6A,0xDB,0x07,0x39,0x72,0xFE,0x15,0x2F,0x14,
0xD3,0x77,0x4F,0xB6,0xD8,0x5D,0xE9,0x5E,0xB9,0x93,0x23,0xBF,0x90,0x17,0xCE,0xB6,0xF2,0x08,0x56,0x24,0x08,0x08,0x12,
0x04,0x04,0x09,0x02,0x82,0x04,0x01,0x41,0x82,0xC0,0x7C,0xD3,0xEA,0x4A,0x59,0xE9,0xC8,0x28,0xD0,0xC1,0x8F,0xED,0xAE,
0x83,0x1D,0x79,0x45,0xFF,0x85,0xCD,0x85,0x76,0x3F,0x42,0x7B,0xB6,0xBC,0x05,0xD6,0x8A,0x04,0x01,0x41,0x82,0x80,0x20,
0x41,0x40,0x90,0x20,0x20,0x48,0x10,0x10,0x24,0x08,0x3C,0x94,0xBF,0x1F,0x4D,0xF7,0xF3,0xBD,0xF0,0xAA,0xFD,0xEE,0xC6,
0xD0,0x23,0xEE,0x99,0x4E,0xF1,0xA9,0x1D,0x8B,0xDB,0x5E,0xF4,0xD4,0xF7,0x66,0x45,0x82,0x80,0x20,0x41,0x40,0x90,0x20,
0x20,0x48,0x10,0x10,0x24,0x08,0x8C,0x56,0xED,0x3E,0xAD,0x54,0x42,0xDA,0x8A,0xDF,0x74,0xFB,0xEC,0x91,0x9D,0xA0,0xEE,
0x79,0x93,0x7F,0xBA,0xCE,0xB6,0xFB,0x35,0xFB,0x15,0x9A,0x56,0xE1,0x8B,0x09,0x12,0x04,0x04,0x09,0x02,0x82,0x04,0x01,
0x41,0x82,0x80,0x20,0x41,0x60,0xB4,0xFC,0xBD,0x7B,0xA3,0xB1,0x17,0xAA,0x96,0x97,0x6C,0x82,0x76,0xA4,0x28,0x7C,0xCF,
0xD0,0xD3,0xE9,0xFF,0xD2,0x68,0xFF,0x58,0x39,0x2B,0x12,0x04,0x04,0x09,0x02,0x82,0x04,0x01,0x41,0x82,0x80,0x20,0x41,
0xE0,0x77,0xF7,0xC6,0x44,0x2F,0xBC,0x6F,0x3C,0xE8,0x9E,0x1E,0xCA,0x4F,0x6D,0x63,0xE8,0xEE,0xBD,0x95,0x5E,0xA8,0xDA,
0x7D,0xBA,0xA7,0x28,0xFA,0xF8,0x08,0x56,0x24,0x08,0x08,0x12,0x04,0x04,0x09,0x02,0x82,0x04,0x01,0x41,0x82,0x80,0x20,
0x41,0xE0,0xA1,0x69,0xB5,0x6D,0xFB,0x6B,0xEB,0xB3,0x47,0x86,0x3D,0x0C,0x3A,0xD2,0x55,0xD9,0x36,0xFB,0xB6,0xFF,0x57,
0x71,0x84,0x99,0x0D,0xF0,0xC5,0x04,0x09,0x02,0x82,0x04,0x01,0x41,0x82,0x80,0x20,0x41,0x60,0xFE,0x55,0xF3,0x23,0x25,
0xAF,0x95,0x4D,0x72,0x76,0x5F,0xF4,0x66,0x2F,0xBC,0x2D,0x3F,0xF8,0xB1,0xE9,0xEF,0x7C,0xA5,0x1C,0xE7,0x55,0x73,0xF8,
0x0E,0x82,0x04,0x01,0x41,0x82,0x80,0x20,0x41,0x40,0x90,0x20,0x20,0x48,0x10,0x98,0x9F,0xD9,0xD0,0xF6,0x8F,0x0E,0x5E,
0xA2,0x9D,0x64,0x70,0x64,0x84,0xEA,0x91,0x0D,0xDA,0xEE,0x19,0xED,0xB0,0xFB,0xF7,0xF6,0x68,0xF7,0xBD,0xFD,0x58,0x91,
0x20,0x21,0x48,0x10,0x10,0x24,0x08,0x08,0x12,0x04,0x04,0x09,0x02,0xA3,0x55,0xBB,0x23,0x4D,0xAB,0xED,0xBD,0xB5,0xE3,
0x5D,0x2F,0xA9,0x65,0x3D,0xDA,0xFD,0xA4,0x2F,0xBC,0xCE,0x7D,0x64,0xF4,0xEC,0xCA,0xD9,0xAC,0x48,0x10,0x10,0x24,0x08,
0x08,0x12,0x04,0x04,0x09,0x02,0x82,0x04,0x01,0x41,0x82,0xC0,0xE8,0xCC,0x86,0x4F,0xED,0xD0,0x82,0x53,0x03,0x32,0x47,
0xEE,0xE4,0x85,0xA6,0xD5,0xB6,0x60,0xDD,0x76,0xA3,0x4E,0x1F,0xF8,0x42,0x9B,0xE9,0xC8,0x81,0x8F,0xC7,0xE6,0xBF,0x37,
0x2B,0x12,0x04,0x04,0x09,0x02,0x82,0x04,0x01,0x41,0x82,0x80,0x20,0x41,0x60,0xFB,0xFE,0x48,0x83,0xDA,0xB7,0xBE,0x1F,
0x4D,0x8F,0x02,0x3D,0xD2,0x9E,0xDB,0x16,0x45,0xEF,0x29,0xB1,0x1E,0x69,0x81,0x7D,0x81,0x15,0x09,0x02,0x82,0x04,0x01,
0x41,0x82,0x80,0x20,0x41,0x40,0x90,0x20,0x20,0x48,0x10,0xB8,0xBA,0x69,0x75,0x5A,0x3B,0xF4,0xF4,0xC8,0x93,0xB6,0x23,
0x0A,0x5E,0xD8,0xA0,0xAD,0x7D,0xAE,0xDD,0x63,0x71,0x73,0x56,0x24,0x08,0x08,0x12,0x04,0x04,0x09,0x02,0x82,0x04,0x01,
0x41,0x82,0xC0,0x7C,0xD5,0xAE,0xED,0x35,0x6C,0xAB,0x4F,0x47,0xCA,0x71,0x2B,0x97,0xB8,0xA7,0xFA,0x34,0xE2,0x85,0xA1,
0xA7,0xED,0xDB,0xEC,0x2F,0xFC,0xA1,0xAD,0x48,0x10,0x10,0x24,0x08,0x08,0x12,0x04,0x04,0x09,0x02,0x82,0x04,0x01,0x41,
0x82,0xC0,0xE8,0x46,0x63,0xF3,0x17,0x48,0xFB,0x47,0x5B,0x2F,0x54,0x45,0x3F,0x1D,0xD9,0x04,0xAD,0xFD,0xD8,0x8A,0xDD,
0xD3,0x29,0x5E,0x78,0x52,0x1B,0x8D,0xC1,0x2E,0x82,0x04,0x01,0x41,0x82,0x80,0x20,0x41,0x40,0x90,0x20,0x30,0x5F,0xB5,
0x7B,0xA1,0x25,0x71,0xFA,0xFC,0x2B,0x6E,0xDE,0x98,0x3E,0x3C,0xFF,0xE3,0x25,0x5E,0xA8,0xDA,0x4D,0x7B,0xE1,0x49,0x57,
0x58,0x91,0x20,0x20,0x48,0x10,0x10,0x24,0x08,0x08,0x12,0x04,0x04,0x09,0x02,0x82,0x04,0x81,0x87,0xF2,0xF7,0x0B,0x65,
0xDC,0xE9,0x82,0xF2,0xCD,0x7B,0x57,0xB5,0xFB,0xD7,0x0F,0x6A,0x9B,0x2F,0xEF,0xF9,0xD3,0x0F,0x9E,0xED,0x08,0x4D,0xAB,
0xB0,0x8B,0x20,0x41,0x40,0x90,0x20,0x20,0x48,0x10,0x10,0x24,0x08,0x3C,0x4C,0x5A,0x3D,0x32,0x1B,0xF5,0x51,0x5B,0x55,
0x3B,0x52,0x7D,0xFA,0xAE,0xD9,0xA8,0x5F,0xF7,0xE2,0xFA,0xA7,0x23,0x95,0xD8,0x1F,0x2B,0x12,0x24,0x04,0x09,0x02,0x82,
0x04,0x01,0x41,0x82,0x80,0x20,0x41,0x40,0x90,0x20,0x70,0x66,0xD2,0x6A,0xDB,0xB4,0xBA,0x72,0x27,0x23,0x5E,0x68,0x81,
0x3D,0x32,0xC4,0xE2,0x0F,0x54,0xA2,0x77,0x77,0x3F,0x3F,0xD2,0xB4,0x0A,0xBB,0x08,0x12,0x04,0x04,0x09,0x02,0x82,0x04,
0x01,0x41,0x82,0xC0,0xE8,0xAB,0xE6,0xD3,0xDA,0x16,0xD8,0xF6,0x63,0x2B,0x6E,0x2E,0x79,0xBD,0x30,0x58,0x74,0xE4,0xA2,
0xF7,0x78,0xE1,0x17,0x62,0x45,0x82,0x80,0x20,0x41,0x40,0x90,0x20,0x20,0x48,0x10,0x10,0x24,0x08,0x08,0x12,0x04,0xE6,
0x67,0x36,0xB4,0xEE,0xD9,0x41,0x6C,0xBA,0x76,0x7C,0xE4,0x7B,0x7B,0xE1,0xFF,0x03,0xDA,0x62,0xFA,0x91,0xF1,0xAE,0xED,
0xB1,0x9A,0x56,0x61,0x17,0x41,0x82,0x80,0x20,0x41,0x40,0x90,0x20,0x20,0x48,0x10,0x78,0xA8,0xDA,0xDD,0xD3,0x7D,0xB8,
0xFB,0x45,0xE2,0x3F,0xD0,0xDB,0x3A,0x68,0xA5,0x75,0x78,0xFA,0x12,0x8F,0x67,0x9B,0xBE,0xC4,0x91,0xC2,0xA3,0x49,0xAB,
0xF0,0x2A,0x41,0x82,0x80,0x20,0x41,0x40,0x90,0x20,0x20,0x48,0x10,0x10,0x24,0x08,0x3C,0x94,0xBF,0x1F,0x1D,0x19,0xC8,
0x3A,0xA8,0x1D,0xED,0x30,0x58,0x2A,0x9D,0xEE,0x64,0xBD,0xA4,0x20,0xFE,0xE8,0x9E,0x3D,0xE6,0x46,0xCE,0x9F,0x5B,0x69,
0xCF,0xB5,0x22,0x41,0x40,0x90,0x20,0x20,0x48,0x10,0x10,0x24,0x08,0x08,0x12,0x04,0x46,0xAB,0x76,0x9F,0xDA,0x3A,0xDB,
0x8A,0xDD,0x1B,0x1F,0xB5,0xED,0x92,0xE3,0x77,0x32,0x7D,0xB6,0x41,0xBB,0xDF,0xBD,0x5F,0x71,0x64,0xDC,0xEF,0xE0,0x6D,
0x78,0xD5,0x1C,0x76,0x11,0x24,0x08,0x08,0x12,0x04,0x04,0x09,0x02,0x82,0x04,0x01,0x41,0x82,0xC0,0x7C,0xF9,0xFB,0x88,
0x95,0x32,0xF1,0xEE,0x4A,0xF4,0x91,0x9A,0x7E,0xDB,0x18,0x3A,0x68,0xA5,0x27,0x78,0xE4,0xC0,0xC7,0x63,0x8F,0x0C,0xB2,
0x1D,0x67,0x45,0x82,0x80,0x20,0x41,0x40,0x90,0x20,0x20,0x48,0x10,0x10,0x24,0x08,0x7C,0x59,0xD5,0xEE,0xD1,0x74,0xF3,
0xE5,0xEE,0xDB,0x78,0xD4,0xDE,0x5B,0x5B,0x8A,0x5C,0x71,0x64,0x84,0xEA,0xCA,0x25,0x5A,0x56,0x24,0x08,0x08,0x12,0x04,
0x04,0x09,0x02,0x82,0x04,0x01,0x41,0x82,0x80,0x20,0x41,0x60,0xBE,0xFC,0x7D,0x79,0x13,0xE1,0x88,0xB6,0x5D,0xF2,0x9E,
0x09,0x10,0x83,0x76,0x17,0x85,0x5F,0xE8,0x30,0x9E,0x96,0xFF,0x07,0x89,0x15,0x09,0x02,0x82,0x04,0x01,0x41,0x82,0x80,
0x20,0x41,0x40,0x90,0x20,0x30,0x5A,0xB5,0xBB,0x79,0x57,0x9F,0x4F,0x2F,0xF4,0x41,0xB6,0x9B,0x32,0x4D,0x5F,0xF4,0x51,
0x5B,0x2A,0x1C,0x74,0x64,0x36,0xEA,0xEE,0x7E,0x65,0xFB,0x23,0xC1,0xAB,0x04,0x09,0x02,0x82,0x04,0x01,0x41,0x82,0x80,
0x20,0x41,0x40,0x90,0x20,0xF0,0xFB,0x07,0x7A,0x4F,0xE1,0x38,0x2B,0x12,0x04,0x04,0x09,0x02,0x82,0x04,0x01,0x41,0x82,
0x80,0x20,0x41,0x40,0x90,0x20,0xF0,0x7F,0xCC,0x3C,0x82,0x7B,0xEB,0xE0,0xBD,0xA8,0x00,0x00,0x00,0x00,0x49,0x45,0x4E,
0x44,0xAE,0x42,0x60,0x82 };
//-------------------------------------------------------------------------------------------------------

//------------------------------------------move---------------------------------------------------------
char mov[] = "delru0123456789";
//-------------------------------------------------------------------------------------------------------

//--------------------------------------check debug------------------------------------------------------
bool isdbg()
{
	bool a;
	if (IsDebuggerPresent())
		return 1;
	else
		return 0;
}
//-------------------------------------------------------------------------------------------------------
void delay(int a)
{
	time_t start, end;
	time(&start);
	time(&end);
	while (difftime(end, start) < a)
	{
		time(&end);
	}
}
void print_ticket()
{
	printf("\noh,wait! Take your ticket\n");
	printf("printing ticket ...\n");
	delay(2);
	printf("printing ticket ....\n");
	delay(2);
	printf("printing ticket .....\n");
	delay(2);
	printf("printing ticket ......\n");
	delay(2);
	printf("printing ticket .......\n");
	delay(2);
	printf("printing ticket ........\n");
	delay(2);
	printf("printing ticket .........\n");
	delay(2);
	printf("printing ticket ..........\n");
	delay(2);
	printf("printing ticket ...........\n");
	delay(2);
	printf("printing ticket ............\n");
	delay(2);
	printf("printing ticket .............\n\n\n");
	FILE *fp;
	fp = fopen("flag.png", "wb");
	fwrite(p,1,1930, fp);
	fclose(fp);
	printf("print finished,view the path to this file,you will get a png file,have a good time\n\n\n");
	system("pause");
}

void sorry()
{
	printf("key error\n");
	system("pause");
}

//---------------------------------maze_move---------------------------------------
void down(int *num,int k2)
{
	int sum = *num;
	while (k2--)
	{
		int r;
		if (sum / 26 > 10)
			return;
		r = p1[sum + 26] ^ p2[sum + 26];
		if (r)
			return;
		sum += 26;
	}
	*num = sum;
}

void up(int *num, int k2)
{
	int sum = *num;
	while (k2--)
	{
		int r;
		if (sum / 26 < 1)
			return;
		r = p1[sum - 26] ^ p2[sum - 26];
		if (r)
			return;
		sum -= 26;
	}
	*num = sum;
}

void left(int *num, int k2)
{
	int sum = *num;
	while (k2--)
	{
		int r;
		if (sum % 26 < 1)
			return;
		r = p1[sum - 1] ^ p2[sum - 1];
		if (r)
			return;
		sum -= 1;
	}
	*num = sum;
}

void right(int *num, int k2)
{
	int sum = *num;
	while (k2--)
	{
		int r;
		if (sum % 26 > 24)
			return;
		r = p1[sum + 1] ^ p2[sum + 1];
		if (r)
			return;
		sum+= 1;
	}
	*num = sum;
}
//-----------------------------------------------------------------------------

int maze_game(char *key)
{
	int n=0,k1,k2,nn=0,sum=0;
	while (n++ < 12)
	{
		if (isdbg())
			exit(0);
		switch (key[nn++])
		{
			case '0':k1=0;break;
			case '1':k1 = 1;break;
			case '2':k1 = 2;break;
			case '3':k1 = 3;break;
			case '4':k1 = 4;break;
			default:return 0;
		}
		switch (key[nn++])
		{
			case '5':k2 = 5;break;
			case '6':k2 = 6;break;
			case '7':k2 = 7;break;
			case '8':k2 = 8;break;
			case '9':k2 = 9;break;
			case 'a':k2 = 10;break;
			case 'b':k2 = 11;break;
			case 'c':k2 = 12;break;
			case 'd':k2 = 13;break;
			case 'e':k2 = 14;break;
			case 'f':k2 = 15;break;
			default:return 0;
		}
		switch (mov[k1])                                                
		{
			case 'd':down(&sum,mov[k2]-'0');break;
			case 'u':up(&sum, mov[k2] - '0');break;
			case 'l':left(&sum, mov[k2] - '0');break;
			case 'r':right(&sum, mov[k2] - '0');break;
			default:return 0;
		}
	}
	if (sum == 311)
		return 1;
	return 0;
}

//-----------------------------------vm----------------------------------------------
unsigned int std_opc_value(unsigned int **vm, unsigned int addr, unsigned int size, unsigned int value)
{
	unsigned int mask;
	switch (size)
	{
	case 1:
		mask = 0xff;
		break;;
	case 2:
		mask = 0xffff;
		break;;
	case 4:
		mask = 0xffffffff;
		break;;
	default:
		mask = 0;
	}
	*(unsigned int *)((char *)*vm + addr) ^= (*(unsigned int *)((char *)*vm + addr) & mask) ^ (value & mask);
	return(value);
}


unsigned int get_mem_value(unsigned int **vm, unsigned int addr, unsigned int size)
{
	unsigned int	value = 0;
	unsigned int	mask;
	switch (size)
	{
	case 1:
		mask = 0xff;
		break;;
	case 2:
		mask = 0xffff;
		break;;
	case 4:
		mask = 0xffffffff;
		break;;
	default:
		mask = 0;
	}
	value = *(unsigned int *)((char *)vm[3] + addr) & mask;
	return(value);
}


unsigned int std_mem_value(unsigned int **vm, unsigned int addr, unsigned int size, unsigned int value)
{
	unsigned int mask;
	switch (size)
	{
	case 1:
		mask = 0xff;
		break;;
	case 2:
		mask = 0xffff;
		break;;
	case 4:
		mask = 0xffffffff;
		break;;
	default:
		mask = 0;
	}
	*(unsigned int *)((char *)vm[3] + addr) ^= (*(unsigned int *)((char *)vm[3] + addr) & mask) ^ (value & mask);
	return(value);
}


unsigned int cmp_value(unsigned int **vm, unsigned int value1, unsigned int value2)
{
	if (value1 == value2)
	{
		*(*(vm + 1) + 7) = 1;
	}
	else if (value1 > value2)
	{
		*(*(vm + 1) + 7) = 2;
	}
	else {
		*(*(vm + 1) + 7) = 0;
	}
	return(value1);
}


unsigned int get_reg_value(unsigned int **vm, unsigned int idx, unsigned int size)
{
	unsigned int	value = 0;
	unsigned int	mask;
	if (idx < 8)
	{
		switch (size)
		{
		case 1:
			mask = 0xff;
			break;;
		case 2:
			mask = 0xffff;
			break;;
		case 4:
			mask = 0xffffffff;
			break;;
		default:
			mask = 0;
		}
		value = vm[1][idx] & mask;
	}
	return(value);
}


unsigned int std_reg_value(unsigned int **vm, unsigned int idx, unsigned int size, unsigned int value)
{
	unsigned int mask;
	if (idx < 8)
	{
		switch (size)
		{
		case 1:
			mask = 0xff;
			break;;
		case 2:
			mask = 0xffff;
			break;;
		case 4:
			mask = 0xffffffff;
			break;;
		default:
			mask = 0;
		}
		vm[1][idx] ^= (vm[1][idx] & mask) ^ (value & mask);
	}
	return(value);
}


unsigned int push(unsigned int **vm, unsigned int value)
{
	*(vm + 2) -= 4;
	*vm[2] = value;
	return(value);
}


unsigned int pop(unsigned int **vm)
{
	unsigned int *value = vm[2];
	*(vm + 2) += 4;
	return(*value);
}


unsigned int reg_add(unsigned int **vm, unsigned int reg1, unsigned int reg2)
{
	unsigned int	v1 = get_reg_value(vm, reg1, 4);
	unsigned int	v2 = get_reg_value(vm, reg2, 4);
	return(std_reg_value(vm, reg1, 4, v1 + v2));
}


unsigned int reg_sub(unsigned int **vm, unsigned int reg1, unsigned int reg2)
{
	unsigned int	v1 = get_reg_value(vm, reg1, 4);
	unsigned int	v2 = get_reg_value(vm, reg2, 4);
	return(std_reg_value(vm, reg1, 4, v1 - v2));
}


unsigned int reg_mul(unsigned int **vm, unsigned int reg1, unsigned int reg2)
{
	unsigned int	v1 = get_reg_value(vm, reg1, 4);
	unsigned int	v2 = get_reg_value(vm, reg2, 4);
	return(std_reg_value(vm, reg1, 4, v1 * v2));
}


unsigned int reg_div(unsigned int **vm, unsigned int reg1, unsigned int reg2)
{
	unsigned int	v1 = get_reg_value(vm, reg1, 4);
	unsigned int	v2 = get_reg_value(vm, reg2, 4);
	return(std_reg_value(vm, reg1, 4, v1 / v2));
}


unsigned int reg_and(unsigned int **vm, unsigned int reg1, unsigned int reg2)
{
	unsigned int	v1 = get_reg_value(vm, reg1, 4);
	unsigned int	v2 = get_reg_value(vm, reg2, 4);
	return(std_reg_value(vm, reg1, 4, v1 & v2));
}


unsigned int reg_or(unsigned int **vm, unsigned int reg1, unsigned int reg2)
{
	unsigned int	v1 = get_reg_value(vm, reg1, 4);
	unsigned int	v2 = get_reg_value(vm, reg2, 4);
	return(std_reg_value(vm, reg1, 4, v1 | v2));
}


unsigned int reg_xor(unsigned int **vm, unsigned int reg1, unsigned int reg2)
{
	unsigned int	v1 = get_reg_value(vm, reg1, 4);
	unsigned int	v2 = get_reg_value(vm, reg2, 4);
	return(std_reg_value(vm, reg1, 4, v1 ^ v2));
}


unsigned int reg_cmp(unsigned int **vm, unsigned int reg1, unsigned int reg2)
{
	unsigned int	v1 = get_reg_value(vm, reg1, 4);
	unsigned int	v2 = get_reg_value(vm, reg2, 4);
	return(cmp_value(vm, v1, v2));
}


unsigned int inc_reg(unsigned int **vm, unsigned int reg1)
{
	unsigned int v1 = get_reg_value(vm, reg1, 4);
	*(char *)vm = *(char *)vm - 1;
	return(std_reg_value(vm, reg1, 4, v1 + 1));
}


unsigned int dec_reg(unsigned int **vm, unsigned int reg1)
{
	unsigned int v1 = get_reg_value(vm, reg1, 4);
	*(char *)vm = *(char *)vm - 1;
	return(std_reg_value(vm, reg1, 4, v1 - 1));
}


unsigned int push_imm(unsigned int **vm, unsigned int value)
{
	*(char *)vm = *(char *)vm + 2;
	return(push(vm, value));
}


unsigned int push_reg(unsigned int **vm, unsigned int reg1)
{
	unsigned int v1 = get_reg_value(vm, reg1, 4);
	*(char *)vm = *(char *)vm - 1;
	return(push(vm, v1));
}


unsigned int pop_reg(unsigned int **vm, unsigned int reg1)
{
	unsigned int v1 = pop(vm);
	*(char *)vm = *(char *)vm - 1;
	return(std_reg_value(vm, reg1, 4, v1));
}


unsigned int reg_mov_reg(unsigned int **vm, unsigned int reg1, unsigned int reg2)
{
	unsigned int v2 = get_reg_value(vm, reg2, 4);
	return(std_reg_value(vm, reg1, 4, v2));
}


unsigned int mem_mov_reg(unsigned int **vm, unsigned int reg1, unsigned int addr, unsigned int size)
{
	unsigned int v2 = get_mem_value(vm, addr, size);
	*(char *)vm = *(char *)vm + 3;
	return(std_reg_value(vm, reg1, size, v2));
}

unsigned int nmem_mov_reg(unsigned int **vm, unsigned int reg1, unsigned int addr, unsigned int size)
{
	unsigned int n=get_reg_value(vm, addr, size);
	unsigned int v2 = get_mem_value(vm, n, size);
	*(char *)vm = *(char *)vm + 3;
	return(std_reg_value(vm, reg1, size, v2));
}


unsigned int reg_mov_mem(unsigned int **vm, unsigned int reg1, unsigned int addr, unsigned int size)
{
	unsigned int v1 = get_reg_value(vm, reg1, size);
	*(char *)vm = *(char *)vm + 3;
	return(std_mem_value(vm, addr, size, v1));
}
unsigned int reg_mov_nmem(unsigned int **vm, unsigned int reg1, unsigned int addr, unsigned int size)
{
	unsigned int n = get_reg_value(vm, addr, size);
	unsigned int v1 = get_reg_value(vm, reg1, size);
	*(char *)vm = *(char *)vm + 3;
	return(std_mem_value(vm, n, size, v1));
}


unsigned int jmp(unsigned int **vm, unsigned int addr)
{
	*(char *)vm = *(char *)vm - addr-3;
	return(0);
}


unsigned int je(unsigned int **vm, unsigned int addr)
{
	if (*(*(vm + 1) + 7) == 1)
	{
		jmp(vm, addr);
	}
	else {
		*(char *)vm = *(char *)vm + 2;
	}
	return(0);
}

void checkcheck(unsigned int **vm, unsigned int reg1, unsigned int addr, unsigned int size)
{
	if (IsDebuggerPresent())
		exit(0);
}
unsigned int jne(unsigned int **vm, unsigned int addr)
{
	if (*(*(vm + 1) + 7) != 1)
	{
		jmp(vm, addr);
	}
	else {
		*(char *)vm = *(char *)vm + 2;
	}
	return(0);
}


unsigned int jg(unsigned int **vm, unsigned int addr)
{
	if (*(*(vm + 1) + 7) == 2)
	{
		jmp(vm, addr);
	}
	else {
		*(char *)vm = *(char *)vm + 2;
	}
	return(0);
}


unsigned int jl(unsigned int **vm, unsigned int addr)
{
	if (*(*(vm + 1) + 7) == 0)
	{
		jmp(vm, addr);
	}
	else {
		*(char *)vm = *(char *)vm + 2;
	}
	return(0);
}


unsigned int jge(unsigned int **vm, unsigned int addr)
{
	if (*(*(vm + 1) + 7) >= 1)
	{
		jmp(vm, addr);
	}
	else {
		*(char *)vm = *(char *)vm + 2;
	}
	return(0);
}


unsigned int jle(unsigned int **vm, unsigned int addr)
{
	if (*(*(vm + 1) + 7) <= 1)
	{
		jmp(vm, addr);
	}
	else {
		*(char *)vm = *(char *)vm + 2;
	}
	return(0);
}


unsigned int smc(unsigned int **vm, unsigned int reg1, unsigned int size)
{
	unsigned int v1 = get_reg_value(vm, reg1, size);
	*(char *)vm = *(char *)vm - 1;
	return(std_opc_value(vm, 5, size, v1));
}

unsigned char opc[] = { 112,0,0,0,0,5,229,24,0,0,0,0,203,6,0,1,139,0,5,0,0,0,0,46,0,0,0,0,112,0,5,132,0,5,0,0,0,0,12,5,0,195,5,6,0,0,251,30,0,0,0,0,255 };

void vm_handler(unsigned int **vm)
{
	unsigned char	code;
	while (1)
	{
		code = vm[0][0];
		switch (code)
		{
		case 193:
			reg_add(vm, (unsigned int)((char *)*vm)[1], (unsigned int)((char *)*vm)[2]);
			break;
		case 133:
			reg_sub(vm, (unsigned int)((char *)*vm)[1], (unsigned int)((char *)*vm)[2]);
			break;
		case 21:
			reg_mul(vm, (unsigned int)((char *)*vm)[1], (unsigned int)((char *)*vm)[2]);
			break;
		case 183:
			reg_div(vm, (unsigned int)((char *)*vm)[1], (unsigned int)((char *)*vm)[2]);
			break;
		case 49:
			reg_and(vm, (unsigned int)((char *)*vm)[1], (unsigned int)((char *)*vm)[2]);
			break;
		case 169:
			reg_or(vm, (unsigned int)((char *)*vm)[1], (unsigned int)((char *)*vm)[2]);
			break;
		case 112:
			reg_xor(vm, (unsigned int)((char *)*vm)[1], (unsigned int)((char *)*vm)[2]);
			break;
		case 195:
			reg_cmp(vm, (unsigned int)((char *)*vm)[1], (unsigned int)((char *)*vm)[2]);
			break;
		case 12:
			inc_reg(vm, (unsigned int)((char *)*vm)[1]);
			break;
		case 160:
			dec_reg(vm, (unsigned int)((char *)*vm)[1]);
			break;
		case 229:
			push_imm(vm, *(unsigned int *)((char *)*vm + 1));
			break;
		case 103:
			push_reg(vm, (unsigned int)((char *)*vm)[1]);
			break;
		case 203:
			pop_reg(vm, (unsigned int)((char *)*vm)[1]);
			break;
		case 45:
			reg_mov_reg(vm, (unsigned int)((char *)*vm)[1], (unsigned int)((char *)*vm)[2]);
			break;
		case 46:
			checkcheck(vm, (unsigned int)((char *)*vm)[1], *(unsigned int *)((char *)*vm + 2),1);
			break;
		case 138:
			mem_mov_reg(vm, (unsigned int)((char *)*vm)[1], *(unsigned int *)((char *)*vm + 2), 1);
			break;
		case 139:
			nmem_mov_reg(vm, (unsigned int)((char *)*vm)[1], *(unsigned int *)((char *)*vm + 2), 1);
			break;
		case 242:
			mem_mov_reg(vm, (unsigned int)((char *)*vm)[1], *(unsigned int *)((char *)*vm + 2), 2);
			break;
		case 243:
			nmem_mov_reg(vm, (unsigned int)((char *)*vm)[1], *(unsigned int *)((char *)*vm + 2), 2);
			break;
		case 254:
			mem_mov_reg(vm, (unsigned int)((char *)*vm)[1], *(unsigned int *)((char *)*vm + 2), 4);
			break;
		case 253:
			nmem_mov_reg(vm, (unsigned int)((char *)*vm)[1], *(unsigned int *)((char *)*vm + 2), 4);
			break;
		case 131:
			reg_mov_mem(vm, (unsigned int)((char *)*vm)[1], *(unsigned int *)((char *)*vm + 2), 1);
			break;
		case 132:
			reg_mov_nmem(vm, (unsigned int)((char *)*vm)[1], *(unsigned int *)((char *)*vm + 2), 1);
			break;
		case 233:
			reg_mov_mem(vm, (unsigned int)((char *)*vm)[1], *(unsigned int *)((char *)*vm + 2), 2);
			break;
		case 234:
			reg_mov_nmem(vm, (unsigned int)((char *)*vm)[1], *(unsigned int *)((char *)*vm + 2), 2);
			break;
		case 153:
			reg_mov_mem(vm, (unsigned int)((char *)*vm)[1], *(unsigned int *)((char *)*vm + 2), 4);
			break;
		case 154:
			reg_mov_nmem(vm, (unsigned int)((char *)*vm)[1], *(unsigned int *)((char *)*vm + 2), 4);
			break;
		case 172:
			jmp(vm, *(unsigned int *)((char *)*vm + 1));
			break;
		case 20:
			je(vm, *(unsigned int *)((char *)*vm + 1));
			break;
		case 164:
			jne(vm, *(unsigned int *)((char *)*vm + 1));
			break;
		case 54:
			jg(vm, *(unsigned int *)((char *)*vm + 1));
			break;
		case 251:
			jl(vm, *(unsigned int *)((char *)*vm + 1));
			break;
		case 115:
			jge(vm, *(unsigned int *)((char *)*vm + 1));
			break;
		case 42:
			jle(vm, *(unsigned int *)((char *)*vm + 1));
			break;
		case 134:
			smc(vm, (unsigned int)((char *)*vm)[1], 1);
			break;
		case 249:
			smc(vm, (unsigned int)((char *)*vm)[1], 2);
			break;
		case 113:
			smc(vm, (unsigned int)((char *)*vm)[1], 4);
			break;
		case 255:
			return;
		default:
			*(unsigned char *)vm = *(unsigned char *)vm - 2;
			break;
		}
		*(unsigned char *)vm = *(unsigned char *)vm + 3;
	}
}

void vm(char *key)
{
	char		*mem = (char *)malloc(sizeof(char) * 64);
	char		*stk = (char *)malloc(sizeof(char) * 64);
	unsigned int	*reg = (unsigned int *)malloc(sizeof(unsigned int) * 8);
	unsigned int	**vm = (unsigned int * *)malloc(sizeof(unsigned int*) * 4);

	memset(stk, 0, 64);
	memset(mem, 0, 64);
	memset(reg, 0, 32);
	memcpy(mem, key,24);

	*vm = (unsigned int *)opc;
	*(vm + 1) = (unsigned int *)reg;
	*(vm + 2) = (unsigned int *)stk + 32;
	*(vm + 3) = (unsigned int *)mem;
	vm_handler(vm);
	memcpy(key, mem, 24);

	free(mem);
	free(stk);
	free(reg);
	free(vm);
}
//------------------------------------------------------------------------------------


int main()
{
	printf("welcome to zsctf!\n");
	printf("show me your key:");
	char key[50];
	scanf("%s", key);
	if (isdbg())
		exit(0);
	if (strlen(key) != 24)
	{
		sorry();
		return 0;
	}
	key[16] = key[16] ^ 1;
	vm(key);
	for (int i = 0;i < 24;++i)
	{
		if (key[i] >= '0'&&key[i] <= '9' || key[i] >= 'a'&&key[i] <= 'f')
			continue;
		sorry();
		return 0;
	}
	if (maze_game(key))
	{
		printf("done!!!The flag is your input\n");
		delay(4);
		print_ticket();
	}
	else sorry();
	return 0;
}
